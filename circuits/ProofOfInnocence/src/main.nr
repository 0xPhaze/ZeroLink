use dep::std;

global DEPTH: Field = 4;

/// Compute the merkle tree root.
fn compute_merkle_root(key: [u1; DEPTH], leaf: [u8; 32], nodes: [u8; 32 * DEPTH]) -> [u8; 32] {
  // Start with the `leaf` node.
  let mut root: [u8; 32] = leaf;

  for i in 0..DEPTH {
    // std::println(root);

    let n = get_node(nodes, i);
    // let z = zeros(i);

    // Hash current node `root` with left provided node `nodes[i]`
    let mut left = n;
    let mut right = root;

    // Or hash it with right zero subtree `zeros(i)`,
    // depending on `key`s i-th least-significant bit.
    if (key[DEPTH - 1 - i] == 0) {
      left = root;
      right = n;
    }

    root = hash(left, right);
  }

  root
}

/// Hashing function.
fn hash(left: [u8; 32], right: [u8; 32]) -> [u8; 32] {
  let mut concat: [u8; 64] = [0; 64];

  for i in 0..32 {
    concat[i] = left[i];
  }

  for i in 0..32 {
    concat[i + 32] = right[i];
  }

  std::hash::keccak256(concat, 64)
}

/// Get a 32 byte slice from the flattened bytes.
fn get_node(nodes: [u8; 32 * DEPTH], index: Field) -> [u8; 32] {
  let mut out: [u8; 32] = [0; 32];

  for i in 0..32 {
    out[i] = nodes[i + index * 32];
  }

  out
}

fn zeros(level: Field) -> [u8; 32] {
  let mut out: [u8; 32] = [0; 32];

  if level == 0 {
    out = [0xad,0x32,0x28,0xb6,0x76,0xf7,0xd3,0xcd,0x42,0x84,0xa5,0x44,0x3f,0x17,0xf1,0x96,0x2b,0x36,0xe4,0x91,0xb3,0x0a,0x40,0xb2,0x40,0x58,0x49,0xe5,0x97,0xba,0x5f,0xb5];
  }
  if level == 1 {
    out = [0xb4,0xc1,0x19,0x51,0x95,0x7c,0x6f,0x8f,0x64,0x2c,0x4a,0xf6,0x1c,0xd6,0xb2,0x46,0x40,0xfe,0xc6,0xdc,0x7f,0xc6,0x07,0xee,0x82,0x06,0xa9,0x9e,0x92,0x41,0x0d,0x30];
  }
  if level == 2 {
    out = [0x21,0xdd,0xb9,0xa3,0x56,0x81,0x5c,0x3f,0xac,0x10,0x26,0xb6,0xde,0xc5,0xdf,0x31,0x24,0xaf,0xba,0xdb,0x48,0x5c,0x9b,0xa5,0xa3,0xe3,0x39,0x8a,0x04,0xb7,0xba,0x85];
  }
  if level == 3 {
    out = [0xe5,0x87,0x69,0xb3,0x2a,0x1b,0xea,0xf1,0xea,0x27,0x37,0x5a,0x44,0x09,0x5a,0x0d,0x1f,0xb6,0x64,0xce,0x2d,0xd3,0x58,0xe7,0xfc,0xbf,0xb7,0x8c,0x26,0xa1,0x93,0x44];
  }
  if level == 4 {
    out = [0x0e,0xb0,0x1e,0xbf,0xc9,0xed,0x27,0x50,0x0c,0xd4,0xdf,0xc9,0x79,0x27,0x2d,0x1f,0x09,0x13,0xcc,0x9f,0x66,0x54,0x0d,0x7e,0x80,0x05,0x81,0x11,0x09,0xe1,0xcf,0x2d];
  }

  out
}

/// Main circuit.
fn main(
  key: [u1; DEPTH],
  nullifier: pub [u8; 32],
  secret: [u8; 32],
  nodes: [u8; 32 * DEPTH],
  root: pub [u8; 32],
  subsetRoot: pub [u8; 32],
  subsetNodes: [u8; 32 * DEPTH],
) {
  // Compute `leaf` using `nullifier` and `secret`.
  let leaf: [u8; 32] = hash(nullifier, secret);

  // Ensure `leaf` is included in the merkle tree.
  assert(compute_merkle_root(key, leaf, nodes) == root);

  // Ensure `leaf` is not blocked.
  assert(compute_merkle_root(key, zeros(0), subsetNodes) == subsetRoot);
}




/// Tests

/// produces `flatten(zeros(i) for i in 0..DEPTH)`.
fn helper_get_zero_nodes() -> [u8; 32 * DEPTH] {
  let mut nodes = [0; 32 * DEPTH];

  for d in 0..DEPTH {
    let z = zeros(d);

    for i in 0..32 {
      nodes[d * 32 + i] = z[i];
    }
  }

  nodes
}

#[test]
fn test_compute_merkle_root() {
  // This should produce the same root
  // for any `key` value on an empty tree.
  let key       = [0; DEPTH];
  let nodes     = helper_get_zero_nodes();
  let leaf      = zeros(0);
  let root      = zeros(DEPTH);
  let c_root    = compute_merkle_root(key, leaf, nodes);

  assert(root == c_root);

}

/*
└─ a485a894be48e52c245a3efaaee3ff0ad0156aa4f1285e643f18b8a315ef6bf7
   ├─ a1c824e969dad89697d6748ec125a7a3665194f5aa7b1cce4eccee9276cd9d80
   │  ├─ 2aa50fdd705311d93da67f63915ae19d8657fb6f5a71915e02789b15906515bf
   │  │  ├─ b6c1b98a2435907b9fcf3c4cbcd8391d5dc6a25ff6ebb08b8fd879077c1978cb
   │  │  │  ├─ ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
   │  │  │  └─ 2e1d428a1a102b152ad9104dd679817ecbf0206a8427c40dc7210e59c3ee3ffc
   │  │  └─ b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30
   │  │     └─ ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
   │  └─ 7ad6cb97d7a8d2d9df45cbfe0926e89fa845e1bca0895ef0eb6a583caeaf2e55
   │     ├─ 0065073995031daf35f0f3463f34690cf6ca43621efc2128ffe4ea36df1cedd1
   │     │  ├─ 2e1d428a1a102b152ad9104dd679817ecbf0206a8427c40dc7210e59c3ee3ffc
   │     │  └─ ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
   │     └─ b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30
   │        └─ ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
   └─ 2107fceec5ee3edc2b5ff0847b8cf1c3608a94724f20fc7bb2a18e288dd8b0da
      ├─ c8a19589b94bc7c9294890f2284d3677473f9569d3f378424da8b905d7ec412c
      │  ├─ b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30
      │  │  └─ ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
      │  └─ b6c1b98a2435907b9fcf3c4cbcd8391d5dc6a25ff6ebb08b8fd879077c1978cb
      │     ├─ ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
      │     └─ 2e1d428a1a102b152ad9104dd679817ecbf0206a8427c40dc7210e59c3ee3ffc
      └─ 21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85
         └─ b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30
            └─ ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
*/

#[test]
fn test_main() {
  let key       = [0; DEPTH];
  let nullifier = [0x00 as u8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88];
  let secret    = [0x00 as u8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x37];
  let leaf      = hash(nullifier, secret);
  let nodes     = helper_get_zero_nodes();
  let root      = compute_merkle_root(key, leaf, nodes);
  let subsetRoot: [u8; 32] = [0xa4, 0x85, 0xa8, 0x94, 0xbe, 0x48, 0xe5, 0x2c, 0x24, 0x5a, 0x3e, 0xfa, 0xae, 0xe3, 0xff, 0x0a, 0xd0, 0x15, 0x6a, 0xa4, 0xf1, 0x28, 0x5e, 0x64, 0x3f, 0x18, 0xb8, 0xa3, 0x15, 0xef, 0x6b, 0xf7];
  let subsetNodes: [u8; 32*DEPTH] = [
    0x2e, 0x1d, 0x42, 0x8a, 0x1a, 0x10, 0x2b, 0x15, 0x2a, 0xd9, 0x10, 0x4d, 0xd6, 0x79, 0x81, 0x7e, 0xcb, 0xf0, 0x20, 0x6a, 0x84, 0x27, 0xc4, 0x0d, 0xc7, 0x21, 0x0e, 0x59, 0xc3, 0xee, 0x3f, 0xfc,
    0xb4, 0xc1, 0x19, 0x51, 0x95, 0x7c, 0x6f, 0x8f, 0x64, 0x2c, 0x4a, 0xf6, 0x1c, 0xd6, 0xb2, 0x46, 0x40, 0xfe, 0xc6, 0xdc, 0x7f, 0xc6, 0x07, 0xee, 0x82, 0x06, 0xa9, 0x9e, 0x92, 0x41, 0x0d, 0x30,
    0x7a, 0xd6, 0xcb, 0x97, 0xd7, 0xa8, 0xd2, 0xd9, 0xdf, 0x45, 0xcb, 0xfe, 0x09, 0x26, 0xe8, 0x9f, 0xa8, 0x45, 0xe1, 0xbc, 0xa0, 0x89, 0x5e, 0xf0, 0xeb, 0x6a, 0x58, 0x3c, 0xae, 0xaf, 0x2e, 0x55,
    0x21, 0x07, 0xfc, 0xee, 0xc5, 0xee, 0x3e, 0xdc, 0x2b, 0x5f, 0xf0, 0x84, 0x7b, 0x8c, 0xf1, 0xc3, 0x60, 0x8a, 0x94, 0x72, 0x4f, 0x20, 0xfc, 0x7b, 0xb2, 0xa1, 0x8e, 0x28, 0x8d, 0xd8, 0xb0, 0xda
  ];


  std::println("key =");
  std::println(key);
  std::println("nullifier =");
  std::println(nullifier);
  std::println("secret =");
  std::println(secret);
  std::println("leaf =");
  std::println(leaf);
  std::println("nodes =");
  std::println(nodes);
  std::println("root =");
  std::println(root);
  std::println("subsetRoot =");
  std::println(subsetRoot);
  std::println("subsetNodes =");
  std::println(subsetNodes);

  main(key, nullifier, secret, nodes, root, subsetRoot, subsetNodes);
}

#[test]
fn test_zeros() {
  assert(zeros(0) == [0xad,0x32,0x28,0xb6,0x76,0xf7,0xd3,0xcd,0x42,0x84,0xa5,0x44,0x3f,0x17,0xf1,0x96,0x2b,0x36,0xe4,0x91,0xb3,0x0a,0x40,0xb2,0x40,0x58,0x49,0xe5,0x97,0xba,0x5f,0xb5]);
  assert(zeros(1) == [0xb4,0xc1,0x19,0x51,0x95,0x7c,0x6f,0x8f,0x64,0x2c,0x4a,0xf6,0x1c,0xd6,0xb2,0x46,0x40,0xfe,0xc6,0xdc,0x7f,0xc6,0x07,0xee,0x82,0x06,0xa9,0x9e,0x92,0x41,0x0d,0x30]);
  assert(zeros(2) == [0x21,0xdd,0xb9,0xa3,0x56,0x81,0x5c,0x3f,0xac,0x10,0x26,0xb6,0xde,0xc5,0xdf,0x31,0x24,0xaf,0xba,0xdb,0x48,0x5c,0x9b,0xa5,0xa3,0xe3,0x39,0x8a,0x04,0xb7,0xba,0x85]);
  assert(zeros(3) == [0xe5,0x87,0x69,0xb3,0x2a,0x1b,0xea,0xf1,0xea,0x27,0x37,0x5a,0x44,0x09,0x5a,0x0d,0x1f,0xb6,0x64,0xce,0x2d,0xd3,0x58,0xe7,0xfc,0xbf,0xb7,0x8c,0x26,0xa1,0x93,0x44]);
  assert(zeros(4) == [0x0e,0xb0,0x1e,0xbf,0xc9,0xed,0x27,0x50,0x0c,0xd4,0xdf,0xc9,0x79,0x27,0x2d,0x1f,0x09,0x13,0xcc,0x9f,0x66,0x54,0x0d,0x7e,0x80,0x05,0x81,0x11,0x09,0xe1,0xcf,0x2d]);
}